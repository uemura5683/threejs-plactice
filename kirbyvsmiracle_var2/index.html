<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <style type="text/css">
      body {
        background:black;
      }
    </style>
  </head>
  <body>
    <div id="myCanvas"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js",
          "three-nodes/": "https://threejs.org/examples/jsm/nodes/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import * as Nodes from 'https://threejs.org/examples/jsm/nodes/Nodes.js';
      import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';
      import { GUI } from 'https://threejs.org/examples/jsm/libs/lil-gui.module.min.js';
      import { Lensflare, LensflareElement } from 'https://threejs.org/examples/jsm/objects/Lensflare.js';
      import { nodeFrame } from 'https://threejs.org/examples/jsm/renderers/webgl/nodes/WebGLNodes.js';
      /**
      * default
      **/
      let scene    = null,
          camera   = null,
          renderer = null,
          controls = null,
          miracle  = null,
          clock    = null,
          width    = 0,
          height   = 0,
          smokeParticles = [],
          objdata = 'normal',
          gui,
          guiObj,
          stats,
          modes = ['normal', 'stone', 'fire', 'bom', 'cutter', 'nirdle', 'ice', 'spark'];

      /**
      * init
      **/
      function init() {
        // width height
        width = window.innerWidth,
        height = window.innerHeight;

        // scene
        scene = new THREE.Scene();

        // camera
        camera = new THREE.PerspectiveCamera(45, width / height);
        camera.position.set(0, 160, 1100);

        // renderer
        renderer = new THREE.WebGLRenderer({
          alpha: true
        });
        renderer.setPixelRatio(
          window.devicePixelRatio
        );
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        clock = new THREE.Clock();

        addLights(1,1,1);

        // smoke
        const smokeTexture  = new THREE.TextureLoader().load('https://threejs-plactice.vercel.app/kirbyvsmiracle/smoke.png');
        const smokeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff, opacity: 0.1, map: smokeTexture, transparent: true});
        const smokeGeo      = new THREE.PlaneGeometry(300,300);

        for (let p = 0; p < 150; p++) {
            let particle = new THREE.Mesh(smokeGeo,smokeMaterial);
            particle.position.set(Math.random()*1000-250,Math.random()*1000-250,Math.random()*2000-250);
            particle.rotation.z = Math.random() * 500;
            scene.add(particle);
            smokeParticles.push(particle);
        }

        // GUI
        let guiCtrl = function(){
          this.mode = 'normal';
        };

        gui = new GUI();
        guiObj = new guiCtrl();
        let folder = gui.addFolder('Folder')
          , modeController = gui.add(guiObj, 'mode', modes);

        modeController.onChange(function(value) {
          setCameraPosition(value);
        });

        folder.open();

        function setCameraPosition(objdata){
          drawMiracle(objdata);
        }

        // draw
        drawMiracle(objdata);
        document.getElementById('myCanvas').appendChild(renderer.domElement);
        window.addEventListener('resize',onResize,false);
      }

      /**
      * lights
      **/
      function addLights(x,y,z) {
        const directLight1 = new THREE.HemisphereLight(0xffffff, 0xefefef, 1);
        scene.add(directLight1);

      }

      /**
      * draw
      **/
      function drawMiracle(data) {
        if(miracle !== null) {
          scene.remove(miracle.group);
        }
        switch(true) {
          case data == 'stone':
            miracle = new StoneMiracle();
            break;
          case data == 'fire':
            miracle = new FireMiracle();          
            break;
          case data == 'cutter':
            miracle = new CutterMiracle();
            break;    
          case data == 'spark':
            miracle = new SparkrMiracle();
            break;
          case data == 'ice':
            miracle = new IceMiracle();
            break;
          case data == 'nirdle':
            miracle = new NirdleMiracle();
            break;
          case data == 'bom':
            miracle = new BomMiracle();
            break;
          default:
            miracle = new Miracle();
            break;
        }
        scene.add(miracle.group);
      }

      /**
      * resize
      **/
      function onResize() {
        width = window.innerWidth;
        height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      /**
      * degree
      **/
      function degree(degrees) {
        return degrees * (Math.PI / 180);
      }

      /**
      * animate
      **/
      function animate() {
        let delta = clock.getDelta();
        requestAnimationFrame(animate);
        [].forEach.call(smokeParticles, sp => {
          sp.rotation.z += delta * 0.2;
        });
        render();
      }

      /**
      * evolveSmoke
      **/
      function evolveSmoke() {
        var sp = smokeParticles.length;
        while(sp--) {
          smokeParticles[sp].rotation.z += (delta * 0.2);
        }
      }

      /**
      * render
      **/
      function render() {
        miracle.moveBody();
        nodeFrame.update();
        renderer.render(scene, camera);
      }

      /**
      * Miracle
      **/
      class Miracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 0, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {
          // body
          const body_geometry = new THREE.IcosahedronGeometry(160, 0 );
          const body_material = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
          const body          = new THREE.Mesh(body_geometry, body_material);
          body.position.set(0, 0, 0);
          body.rotation.set(degree(0), degree(15), degree(30));
          this.group.add(body);

          // eye
          function eye_content (px,py,pz,bpz,rx,ry,rz,group) {
            const eye_geometry =  new THREE.CylinderGeometry( 40, 40, 1, 32 );
            const eyes_material = new THREE.MeshLambertMaterial({color: 0xEE1A2B});
            const eye = new THREE.Mesh(eye_geometry, eyes_material);
            const eye_black_geometry = new THREE.CylinderGeometry( 20, 20, 1, 32 );
            const eye_black_material = new THREE.MeshLambertMaterial({color: 0x000000});
            const eye_black = new THREE.Mesh(eye_black_geometry, eye_black_material);
            eye.position.set(px, py, pz);
            eye.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(eye);
            eye_black.position.set(px, py, bpz);
            eye_black.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(eye_black);
          }
          eye_content(-9, -22, 128, 129, 100, 0, 0, this.group);
          eye_content(9, 22, -128, -129, 100, 0, 0, this.group);
          eye_content(72, 22, 106, 107, 80, 0, -30, this.group);
          eye_content(-72, -22, -106, -107, 80, 0, -30, this.group);
          eye_content(117, -24, 45, 46, 120, 0, -66, this.group);
          eye_content(-117, 24, -45, -46, 120, 0, -66, this.group);
          eye_content(123, 20, -35, -36, 120, 0, -105, this.group);
          eye_content(-123, -20, 35, 36, 120, 0, -105, this.group);
          eye_content(-82, 22, 97, 98, 75, 0, 41, this.group);
          eye_content(82, -22, -97, -98, 75, 0, 41, this.group);
          eye_content(-50, 105, 54, 55, 75, -60, 50, this.group);
          eye_content(50, -105, -54, -55, 75, -60, 50, this.group);
          eye_content(40, 105, 62, 63, 33, 0, -21, this.group);
          eye_content(-40, -105, -62, -63, 33, 0, -21, this.group);
          eye_content(75, 105, -20, -21, 100, 50, -110, this.group);
          eye_content(-75, -105, 20, 21, 100, 50, -110, this.group);
          eye_content(9, 105, -75, -76, 90, 85, -125, this.group);
          eye_content(-9, -105, 75, 76, 90, 85, -125, this.group);
          eye_content(-67, 105, -35, -36, 165, 0, -32, this.group);
          eye_content(67, -105, 35, 36, 165, 0, -32, this.group);
        }
        moveBody() {
          const bodyamplitude = 50;
          this.bodyangle += 0.05;
          this.group.rotation.y += 0.05;
          this.group.rotation.z += 0.05;
          this.group.position.y = 200 - (Math.cos(this.bodyangle) * bodyamplitude);
        }  
      }

      /**
      * StoneMiracle
      **/
      class StoneMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 200, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {
          // body
          const body_geometry = new THREE.BoxGeometry(150, 150, 200 );
          const body_material = new THREE.MeshLambertMaterial({color: 0x7f2116});
          const body          = new THREE.Mesh(body_geometry, body_material);
          body.position.set(0, 0, 0);
          this.group.add(body);
          function stone_cylinder(px,py,pz,rx,ry,rz,color,group) {
            const bosy_geometry = new THREE.CylinderGeometry(75, 120, 40, 4);
            const body_material = new THREE.MeshLambertMaterial({color: color});
            const body          = new THREE.Mesh(bosy_geometry, body_material);
            body.position.set(px, py, pz);
            body.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(body);
          }
          stone_cylinder( 0, 105, 0, 0, 45, 0, 0xa5291c, this.group);
          stone_cylinder( 0, -105, 0, 0, 45, 180, 0x3f100b, this.group);
          stone_cylinder( -105, 0, 0, 45, 0, 90, 0x6d1b12, this.group);
          stone_cylinder( 105, 0, 0, -45, 0, -90, 0x6d1b12, this.group);
          stone_cylinder( 0, 0, 105, 90, 45, 0, 0x822016, this.group);
          stone_cylinder( 0, 0, -105, -90, -45, 0, 0x822016, this.group);
        }
        moveBody() {
          const bodyamplitude = 300;
          this.bodyangle -= 0.02;
          this.group.rotation.z += 0.05;    
          this.group.position.x = 0 - (Math.cos(this.bodyangle) * bodyamplitude);
        }  
      }

      /**
      * FireMiracle
      **/
      class FireMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 0, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {

          // body
          const sphereGeometry = new THREE.SphereGeometry( 125, 125, 16 );
          const geometry = new THREE.BufferGeometry();

          // buffers
          const speed = []
          const intensity = [];
          const size = [];

          const positionAttribute = sphereGeometry.getAttribute( 'position' );
          const particleCount = positionAttribute.count;

          for ( let i = 0; i < particleCount; i ++ ) {
            speed.push( 20 + Math.random() * 50 );
            intensity.push( Math.random() * .15 );
            size.push( 250 + Math.random() * 230 );
          }

          geometry.setAttribute( 'position', positionAttribute );
          geometry.setAttribute( 'targetPosition', sphereGeometry.getAttribute( 'position' ) );
          geometry.setAttribute( 'particleSpeed', new THREE.Float32BufferAttribute( speed, 1 ) );
          geometry.setAttribute( 'particleIntensity', new THREE.Float32BufferAttribute( intensity, 1 ) );
          geometry.setAttribute( 'particleSize', new THREE.Float32BufferAttribute( size, 1 ) );

          // maps
          const fireMap = new THREE.TextureLoader().load( 'https://threejs-plactice.vercel.app/kirbyvsmiracle_var2/fire.jpg' );

          // nodes
          const targetPosition = new Nodes.AttributeNode( 'targetPosition', 'vec3' );
          const particleSpeed = new Nodes.AttributeNode( 'particleSpeed', 'float' );
          const particleIntensity = new Nodes.AttributeNode( 'particleIntensity', 'float' );
          const particleSize = new Nodes.AttributeNode( 'particleSize', 'float' );
          const time = new Nodes.TimerNode();
          const spriteSheetCount = new Nodes.ConstNode( new THREE.Vector2( 6, 6 ) );
          const fireUV = new Nodes.SpriteSheetUVNode(
            spriteSheetCount,
            new Nodes.PointUVNode(),
            new Nodes.OperatorNode( '*', time, particleSpeed )
          );
          const fireSprite = new Nodes.TextureNode( fireMap, fireUV );
          const fire = new Nodes.OperatorNode( '*', fireSprite, particleIntensity );
          const lerpPosition = new Nodes.UniformNode( 1 );
          const positionNode = new Nodes.MathNode( Nodes.MathNode.MIX, new Nodes.PositionNode( Nodes.PositionNode.LOCAL ), targetPosition, lerpPosition );
          const material = new Nodes.PointsNodeMaterial( {
            depthWrite: false,
            transparent: true,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending
          } );

          material.colorNode = fire;
          material.sizeNode = particleSize;
          material.positionNode = positionNode;

          const particles = new THREE.Points( geometry, material );
          particles.position.set(0, 0, 0);

          this.group.add( particles );

          // eye
          function eye_content (px,py,pz,bpz,rx,ry,rz,group) {
            const eye_geometry =  new THREE.CylinderGeometry( 40, 40, 1, 32 );
            const eyes_material = new THREE.MeshLambertMaterial({color: 0xea0c0e});
            const eye = new THREE.Mesh(eye_geometry, eyes_material);
            eye.position.set(px, py, pz);
            eye.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(eye);

            const eye_black_geometry = new THREE.CylinderGeometry( 20, 20, 1, 32 );
            const eye_black_material = new THREE.MeshLambertMaterial({color: 0x000000});
            const eye_black = new THREE.Mesh(eye_black_geometry, eye_black_material);
            eye_black.position.set(px, py, bpz);
            eye_black.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(eye_black);
          }
          eye_content(0, -20, 150, 151, 100, 0, 0, this.group);
        }
        moveBody() {
          const bodyamplitude = 50;
          this.bodyangle += 0.05;
          this.group.position.y = 200 - (Math.cos(this.bodyangle) * bodyamplitude);
        }  
      }

      /**
      * CutterMiracle
      **/
      class CutterMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 0, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {
          // body_top
          function cutter_top(px,py,pz,rx,ry,rz,group) {
            const wing_material = new THREE.MeshPhongMaterial({color: 0x03d600})
                , shape_cutter = new THREE.Shape();
                  shape_cutter.moveTo(-40,  130);
                  shape_cutter.lineTo(20,  110);
                  shape_cutter.lineTo(40,  80);
                  shape_cutter.lineTo(60,  30);
                  shape_cutter.lineTo(60,  -30);
                  shape_cutter.lineTo(40,  -80);
                  shape_cutter.lineTo(20,  -110);
                  shape_cutter.lineTo(-40,  -130);
                  shape_cutter.lineTo(-120, -130);
                  shape_cutter.lineTo(-90,  -100);
                  shape_cutter.lineTo(-70,  -80);
                  shape_cutter.lineTo(-50, -30);            
                  shape_cutter.lineTo(-50, 30);
                  shape_cutter.lineTo(-70,  80);
                  shape_cutter.lineTo(-90,  100);
                  shape_cutter.lineTo(-120,  130);
            const wing_geometry = new THREE.ShapeGeometry(shape_cutter),
                  wing_box = new THREE.Mesh(wing_geometry, wing_material);
            wing_box.position.set(px, py, pz);
            wing_box.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(wing_box);
          }
          cutter_top( 0, 105, 0, 0, 0, 90, this.group);
          // body_middle
          function cutter_middle(px,py,pz,rx,ry,rz,group) {
            const wing_material = new THREE.MeshPhongMaterial({color: 0x03d600})
                , shape_cutter = new THREE.Shape();
                  shape_cutter.moveTo(-50,  110);
                  shape_cutter.lineTo(-10,  90);
                  shape_cutter.lineTo(20,  60);
                  shape_cutter.lineTo(30,  25);
                  shape_cutter.lineTo(30,  -25);
                  shape_cutter.lineTo(20,  -60);
                  shape_cutter.lineTo(-10,  -90);
                  shape_cutter.lineTo(-50,  -110);
                  shape_cutter.lineTo(-115, -110);
                  shape_cutter.lineTo(-100,  -90);
                  shape_cutter.lineTo(-75,  -60);
                  shape_cutter.lineTo(-65, -25);            
                  shape_cutter.lineTo(-65, 25);
                  shape_cutter.lineTo(-75,  60);
                  shape_cutter.lineTo(-100,  90);
                  shape_cutter.lineTo(-115,  110);
            const wing_geometry = new THREE.ShapeGeometry(shape_cutter),
                  wing_box = new THREE.Mesh(wing_geometry, wing_material);
            wing_box.position.set(px, py, pz);
            wing_box.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(wing_box);
          }
          cutter_middle( 0, 0, 0, 0, 0, 90, this.group);
          // body_bottom
          function cutter_bottom(px,py,pz,rx,ry,rz,group) {
            const wing_material = new THREE.MeshPhongMaterial({color: 0x1a731e})
                , shape_cutter = new THREE.Shape();
                  shape_cutter.moveTo(-30,   80);
                  shape_cutter.lineTo(0,     70);
                  shape_cutter.lineTo(20,    50);
                  shape_cutter.lineTo(30,    25);
                  shape_cutter.lineTo(30,   -25);
                  shape_cutter.lineTo(20,   -50);
                  shape_cutter.lineTo(0,    -70);
                  shape_cutter.lineTo(-30,  -80);
                  shape_cutter.lineTo(-65,  -80);
                  shape_cutter.lineTo(-60,  -70);
                  shape_cutter.lineTo(-45,  -50);
                  shape_cutter.lineTo(-40,  -25);            
                  shape_cutter.lineTo(-40,   25);
                  shape_cutter.lineTo(-45,   50);
                  shape_cutter.lineTo(-60,   70);
                  shape_cutter.lineTo(-65,   80);
            const wing_geometry = new THREE.ShapeGeometry(shape_cutter),
                  wing_box = new THREE.Mesh(wing_geometry, wing_material);
            wing_box.position.set(px, py, pz);
            wing_box.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(wing_box);
          }
          cutter_bottom( 0, -115, 0, 0, 0, 90, this.group);
        }
        moveBody() {
          const bodyamplitude = 50;
          this.bodyangle += 0.05;
          this.group.position.y = 200 - (Math.cos(this.bodyangle) * bodyamplitude);
        }  
      }

      /**
      * SparkMiracle
      **/
      class SparkrMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(5, 150, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {
          // body
          const body_geometry = new THREE.SphereGeometry( 150, 64, 64 );
          const body_material = new THREE.MeshPhongMaterial({transparent: true, opacity: .4,color: 0xffff91}); 
          const body          = new THREE.Mesh(body_geometry, body_material);
          body.position.set(0, 0, 0);
          this.group.add(body);
          // lensflares
          const textureLoader = new THREE.TextureLoader();
          const textureFlare0 = textureLoader.load( 'https://threejs-plactice.vercel.app/kirbyvsmiracle_var2/lensflare.png' );
          const textureFlare3 = textureLoader.load( 'https://threejs-plactice.vercel.app/kirbyvsmiracle_var2/lensflare1.png' );
          addLight( 0.8, 0.9, 1, 0, 0, 700, this.group );
          addLight( 0.5, 0.8, 0.7, 0, 0, 700, this.group );
          addLight( 0.995, 0.5, 0.9, 0, 0, 700, this.group );
          function addLight( h, s, l, x, y, z, group ) {
            const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );
            light.color.setHSL( h, s, l );
            light.position.set( x, y, z );
            group.add( light );
            const lensflare = new Lensflare();
            lensflare.addElement( new LensflareElement( textureFlare0, 1500, 1, light.color ) );
            lensflare.addElement( new LensflareElement( textureFlare3, 1000, .8 ) );
            lensflare.addElement( new LensflareElement( textureFlare3, 800, .6 ) );
            lensflare.addElement( new LensflareElement( textureFlare3, 2000, .8 ) );
            lensflare.addElement( new LensflareElement( textureFlare3, 1800, .7 ) );
            group.add( lensflare );
          }
        }
        moveBody() {
          const bodyamplitude = 10;
          this.bodyangle += 0.05;
        }  
      }

      /**
      * IceMiracle
      **/
      class IceMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 0, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
          this.drawBackground();
        }
        drawBody() {
          // body
          const body_geometry = new THREE.BoxGeometry(200, 200, 200 );
          const body_material = new THREE.MeshPhongMaterial({transparent: true,opacity: .9,color: 0x00ffed});      
          const body          = new THREE.Mesh(body_geometry, body_material);
          body.position.set(0, 0, 0);
          this.group.add(body);
          function ice_cylinder(px,py,pz,rx,ry,rz,group) {
            const bosy_geometry = new THREE.CylinderGeometry(120, 150, 20, 4);
            const body_material = new THREE.MeshPhongMaterial({transparent: true,opacity: .9,color: 0x00ffed});      
            const body          = new THREE.Mesh(bosy_geometry, body_material);
            body.position.set(px, py, pz);
            body.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(body);
          }
          ice_cylinder( 0, 117, 0, 0, 45, 0, this.group);
          ice_cylinder( 0, -117, 0, 0, 45, 180, this.group);
          ice_cylinder( -117, 0, 0, 45, 0, 90, this.group);
          ice_cylinder( 117, 0, 0, -45, 0, -90, this.group);
          ice_cylinder( 0, 0, 117, 90, 45, 0, this.group);
          ice_cylinder( 0, 0, -117, -90, -45, 0, this.group);
        }
        drawBackground() {
          function generateSprite(colors) {
            var canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;

            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0,   'rgba(255,255,255,.3)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,.5)');
            gradient.addColorStop(0.7, colors);

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            var texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
          }

          createStarField(this.group);
          function createStarField(group) {
            const geometry = new THREE.SphereGeometry(2, 100, 100),
                  size = 1;
            for (let i = 0; i < 250; i++) {
              const light_mesh = ['rgba(215,255,255,.8)', 'rgba(155,255,255,.8)', 'rgba(180,255,255,.8)', 'rgba(255,255,255,.8)', 'rgba(235,255,255,.8)'],
                    light_meshNo = Math.floor( Math.random() * light_mesh.length);
              const material = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                size: 3,
                transparent: true,
                blending: THREE.AdditiveBlending,
                map: generateSprite(light_mesh[light_meshNo])
              })
              const mesh = new THREE.Mesh(geometry, material)
              mesh.position.set(1 * Math.random() - 0.5, 1 * Math.random() - 0.5 , 1 * Math.random() - 0.5 ).normalize()
              mesh.position.multiplyScalar(Math.random() * 300)
              mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2)
              mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 1
              group.add(mesh);
            }
          }
        }
        moveBody() {
          const bodyamplitude = 50;
          this.bodyangle += 0.01;
          this.group.rotation.y += 0.01;
          this.group.position.y = 200 - (Math.cos(this.bodyangle) * bodyamplitude);
        }  
      }

      /**
      * NirdleMiracle
      **/ 
      class NirdleMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 0, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {
          // body
          const body_geometry = new THREE.SphereGeometry( 110, 64, 64 );
          const body_material = new THREE.MeshLambertMaterial({color: 0xffaa00});
          const body          = new THREE.Mesh(body_geometry, body_material);
          function nirdle_cylinder(px,py,pz,rx,ry,rz,group) {
            const bosy_geometry = new THREE.CylinderGeometry(1, 25, 100, 100);
            const body_material = new THREE.MeshLambertMaterial({color: 0xffaa00});      
            const body          = new THREE.Mesh(bosy_geometry, body_material);
            body.position.set(px, py, pz);
            body.rotation.set(degree(rx), degree(ry), degree(rz));
            group.add(body);
          }
          nirdle_cylinder( 0, 150, 0, 0, 45, 0, this.group);
          nirdle_cylinder( 0, -150, 0, 0, 45, 180, this.group);
          nirdle_cylinder( -150, 0, 0, 45, 0, 90, this.group);
          nirdle_cylinder( 150, 0, 0, -45, 0, -90,  this.group);
          nirdle_cylinder( 110, 110, 0, 0, 0, -45, this.group);
          nirdle_cylinder( -110, 110,0, 0, 0, 45, this.group);
          nirdle_cylinder( 110, -110, 0, 0, 0, -135, this.group);
          nirdle_cylinder( -110, -110, 0, 0, 0, 135, this.group);
          body.position.set(0, 0, 0);
          body.rotation.set(degree(0), degree(15), degree(30));
          this.group.add(body);
        }
        moveBody() {
          this.bodyangle += 0.05;
          this.group.rotation.y += 0.05;
          this.group.position.y = 200 - (Math.cos(this.bodyangle) * 50);
        }  
      }

      /**
      * BomMiracle
      **/ 
      class BomMiracle {
        constructor() {
          this.group = new THREE.Group();
          this.group.position.set(0, 200, 0);
          this.group.rotation.set(0, 0, 0);
          this.wingangle = 0;
          this.bodyangle = 0;
          this.drawBody();
        }
        drawBody() {
          // body
          function bom_cylinder(sx,sy,sz,bx,by,bz,px,py,pz,group) {
            const body_geometry = new THREE.SphereGeometry( sx, sy, sz );
            const body_material = new THREE.MeshPhongMaterial({transparent: true,opacity: .7,color: 0x4000000});
            const body          = new THREE.Mesh(body_geometry, body_material);
            body.position.set(px, py, pz);
            group.add(body);

            const body_geometry_big = new THREE.SphereGeometry( bx, by, bz );
            const body_material_big = new THREE.MeshPhongMaterial({transparent: true,opacity: .2,color: 0x4610875});
            const body_big          = new THREE.Mesh(body_geometry_big, body_material_big);
            body_big.position.set(px, py, pz);
            group.add(body_big);

            const bomlight = new THREE.PointLight( 0xffffff, 1, 10000 );
            bomlight.position.set( -400, 400, 400 );
            group.add(bomlight);
          }
          bom_cylinder( 120, 64, 64, 140, 64, 64, 0, 0, 0, this.group);
          bom_cylinder( 25, 64, 64, 35, 64, 64, 0, 160, 60, this.group);
          bom_cylinder( 25, 64, 64, 35, 64, 64, 0, -160, 60, this.group);
          bom_cylinder( 25, 64, 64, 35, 64, 64, -160, 0, 60, this.group);
          bom_cylinder( 25, 64, 64, 35, 64, 64, 160, 0, 60, this.group);
        }
        moveBody() {
          this.bodyangle += 0.05;
          this.group.position.y = 200 - (Math.cos(this.bodyangle) * 10);
        }  
      }
      init();
      animate();
    </script>
  </body>
</html>