
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <script src="https://unpkg.com/three@0.131.3/build/three.min.js"></script>
    <style type="text/css">
      body {
        margin: 0;
        background-image:
          linear-gradient(
            0deg,
            #272d51 0%, #0c0e1b 40%, #000000 70%
          );
      }
    </style>
  </head>
  <body>
    <div id="myCanvas"></div>


    <script type="x-shader/x-vertex" id="vertexshader">
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;
      varying vec2 vUv;
      void main() {
        gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
      }

    </script>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js",
          "three/addons/": "https://threejs.org/examples/jsm/"
        }
      }
    </script>   
    <script type="module">

    import * as THREE from 'three';

    import { Lensflare, LensflareElement } from 'https://threejs.org/examples/jsm/objects/Lensflare.js';
    import { EffectComposer } from 'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'https://threejs.org/examples/jsm/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from 'https://threejs.org/examples/jsm/postprocessing/UnrealBloomPass.js';

    /**
    * default
    **/
    let xmastree  = null, snow = null, snow2 = null, spark = null, font = null, width = window.innerWidth, height = window.innerHeight;
    let ENTIRE_SCENE = 0, BLOOM_SCENE = 1;

    let bloomLayer = new THREE.Layers();
    bloomLayer.set( BLOOM_SCENE );

    let params = {
      exposure: 1,
      bloomStrength: 0,
      bloomThreshold: 0,
      bloomRadius: 0,
      scene: 'Scene with Glow'
    };

    let materials = {};

    let renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    let scene = new THREE.Scene();

    let camera = new THREE.PerspectiveCamera( 45, width / height );
    camera.position.set( 0, 160, 1700 );


    let renderScene = new RenderPass( scene, camera );

    let bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.0, 0.4, 1.0 );
    bloomPass.threshold = params.bloomThreshold;
    bloomPass.strength = params.bloomStrength;
    bloomPass.radius = params.bloomRadius;

    let bloomComposer = new EffectComposer( renderer );
    bloomComposer.renderToScreen = false;
    bloomComposer.addPass( renderScene );
    bloomComposer.addPass( bloomPass );

    let finalPass = new ShaderPass(
      new THREE.ShaderMaterial( {
        uniforms: {
          baseTexture: { value: null },
          bloomTexture: { value: bloomComposer.renderTarget2.texture }
        },
        vertexShader: document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
        defines: {}
      } ), 'baseTexture'
    );
    finalPass.needsSwap = true;

    const finalComposer = new EffectComposer( renderer );
    finalComposer.addPass( renderScene );
    finalComposer.addPass( finalPass );

    // setupScene();

    // function setupScene() {

    //   scene.traverse( disposeMaterial );
    //   scene.children.length = 0;

    //   const geometry = new THREE.IcosahedronGeometry( 30, 15 );

    //   for ( let i = 0; i < 10; i ++ ) {

    //     const color = new THREE.Color();
    //     color.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );

    //     const material = new THREE.MeshBasicMaterial( { color: color } );
    //     const sphere = new THREE.Mesh( geometry, material );
    //     sphere.position.x = Math.random() * 10 - 5;
    //     sphere.position.y = Math.random() * 10 - 5;
    //     sphere.position.z = 400;
    //     scene.add( sphere );
    //     sphere.layers.enable( BLOOM_SCENE );
    //   }
    // }

    // function disposeMaterial( obj ) {
    //   if ( obj.material ) {
    //     obj.material.dispose();
    //   }
    // }

    /**
    * init
    **/
    function init() {
      addLights();
      drawXmasTree();
      drawSnow();
      drawSnow2();
      drawspark();
      drawfont();
      document.getElementById('myCanvas').appendChild(renderer.domElement);
      window.addEventListener('load',onResize,false);
      window.addEventListener('resize',onResize,false);
    }

    /**
    * lights
    **/
    function addLights() {
      decorationlignt(1,1,1);
      decorationlignt(-1,-1,-1);
    }

    function decorationlignt(px,py,pz) {
      const directLight = new THREE.DirectionalLight(0xffffff);
      directLight.castShadow = true;
      directLight.position.set(px, py, pz);
      scene.add(directLight);
    }

    /**
    * draw
    **/
    function drawXmasTree() {
      xmastree = new XmasTree();
      scene.add(xmastree.group);
    }

    function drawSnow() {
      snow = new Snow();
      scene.add(snow.group);
    }

    function drawSnow2() {
      snow2 = new Snow2();
      scene.add(snow2.group);
    }

    function drawspark() {
      spark = new Spark();
      scene.add(spark.group);
    }

    function drawfont() {
      font = new Font();
      scene.add(font.group);
    }

    /**
    * resize
    **/
    function onResize() {
      width = window.innerWidth;
      height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    /**
    * degree
    **/
    function degree(degrees) {
      return degrees * (Math.PI / 180);
    }

    /**
    * animate
    **/
    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    /**
    * render
    **/
    function render() {
      xmastree.moveBody();
      snow.moveBody();
      snow2.moveBody();
      spark.moveBody();
      font.moveBody();
      bloomComposer.render();
      finalComposer.render();
    }

    /**
    * XmasTree
    **/
    class XmasTree {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, -200, 0);
        this.group.rotation.set(degree(0), degree(45), degree(0));
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        function floor(px,py,pz,rx,ry,rz,width,height,thickness,radius,color,group) {
          const floor = new THREE.CylinderGeometry(width, height, thickness, radius);
          const floor_material = new THREE.MeshPhongMaterial({color: color});
          const floor_mesh = new THREE.Mesh(floor, floor_material);
          floor_mesh.position.set(px, py, pz);
          floor_mesh.rotation.set(degree(rx), degree(ry), degree(rz));
          group.add(floor_mesh);
        }
        floor(-220,0,220,0,0,0,200,150,200,4,0xf41322,this.group);
        floor(-200,100,200,0,0,0,180,180,10,4,0x47232a,this.group);
        floor(0,300,0,0,0,0,30,30,500,100,0x50232C,this.group);
        floor(0,300,0,0,0,0,100,300,200,100,0x238B4A,this.group);
        floor(0,450,0,0,0,0,75,250,200,100,0x238B4A,this.group);
        floor(0,600,0,0,0,0,50,200,200,100,0x238B4A,this.group);
        floor(0,750,0,0,0,0,10,150,200,100,0x238B4A,this.group);
      }
      moveBody() {
      }  
    }

    class Snow {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, -window.innerHeight, 0);
        this.group.rotation.set(degree(0), degree(0), degree(0));
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        for (let i = 0; i < 750; i++) {
          let star = ['snowflake1.png', 'snowflake2.png'];
          let starNo = Math.floor( Math.random() * star.length);
          let colors = [[ 1.0, 0.2, 0.8 ], [ 0.95, 0.1, 0.8 ], [ 0.90, 0.05, 0.8 ],[ 0.85, 0, 0.8 ], [ 0.80, 0, 0.8 ]];
          let colorsno = Math.floor( Math.random() * colors.length);
          let size = [20, 15, 10, 8, 5]
          let sizeNo = Math.floor( Math.random() * size.length);

          const snow_material = new THREE.SpriteMaterial({
            map: new THREE.TextureLoader().load(star[starNo]),
          });
          snow_material.fog = true;

          snow_material.color.setHSL( colors[colorsno][0], colors[colorsno][1], colors[colorsno][2] );

          const snow_sprite = new THREE.Sprite(snow_material);
          snow_sprite.position.x = (window.innerWidth * 2) * (Math.random() - 0.5);
          snow_sprite.position.y = (window.innerHeight * 2) * Math.random() - 40;
          snow_sprite.position.z = 2000 * (Math.random() - 0.5);

          snow_sprite.scale.set(size[sizeNo], size[sizeNo], size[sizeNo]);
          this.group.add(snow_sprite);
        }
      }
      moveBody() {
        this.group.rotation.y += 0.005;
      }  
    }

    class Snow2 {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, -window.innerHeight, 0);
        this.group.rotation.set(degree(0), degree(0), degree(0));
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        for (let i = 0; i < 750; i++) {
          let star = ['snowflake3.png'];
          let starNo = Math.floor( Math.random() * star.length);
          let colors = [[ 1.0, 0.2, 0.8 ], [ 0.95, 0.1, 0.8 ], [ 0.90, 0.05, 0.8 ],[ 0.85, 0, 0.8 ], [ 0.80, 0, 0.8 ]];
          let colorsno = Math.floor( Math.random() * colors.length);
          let size = [20, 15, 10, 8, 5]
          let sizeNo = Math.floor( Math.random() * size.length);

          const snow_material = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load(star[starNo]),});
          snow_material.fog = true;
          snow_material.color.setHSL( colors[colorsno][0], colors[colorsno][1], colors[colorsno][2] );

          const snow_sprite = new THREE.Sprite(snow_material);
          snow_sprite.position.x = (window.innerWidth * 2) * (Math.random() - 0.5);
          snow_sprite.position.y = (window.innerHeight * 2) * Math.random() - 40;
          snow_sprite.position.z = 2000 * (Math.random() - 0.5);

          snow_sprite.scale.set(size[sizeNo], size[sizeNo], size[sizeNo]);
          this.group.add(snow_sprite);
        }
      }
      moveBody() {
        this.group.rotation.y -= 0.005;
      }  
    }

    class Spark {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, 0, 0);
        this.group.rotation.set(0, 0, 0);
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        const body_geometry = new THREE.SphereGeometry( 30, 30, 30 );
        const body_material = new THREE.MeshPhongMaterial({transparent: true, opacity: .4,color: 0xffff91}); 
        const body          = new THREE.Mesh(body_geometry, body_material);
        body.position.set(0, 680, 0);
        this.group.add(body);
        const textureLoader = new THREE.TextureLoader();
        const textureFlare0 = textureLoader.load( 'lensflare.png' );
        addLight( 0.8, 0.9, 1, 0, 0, 0, this.group );
        function addLight( h, s, l, x, y, z, group ) {
          const light = new THREE.PointLight( 0xffffff, 1.5, 1000 );
          light.color.setHSL( h, s, l );
          light.position.set( x, y, z );
          group.add( light );
          const lensflare = new Lensflare();
          lensflare.addElement( new LensflareElement( textureFlare0, 200, 1, light.color ) );
          lensflare.position.set(0, -260, 330);
          group.add( lensflare );
        }
      }
      moveBody() {
      }  
    }

    class Font {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, 0, 0);
        this.wingangle = 0;
        this.fonts();
      }
      fonts() {
        // const loader = new THREE.FontLoader();
        // loader.load( 'https://threejs.org/examples/fonts/gentilis_bold.typeface.json', function ( font ) {
        //     const matDark = new THREE.LineBasicMaterial( {
        //                           color: 0x50232C,
        //                           opacity: 1,
        //                           side: THREE.DoubleSide
        //                         } );
        //     const matLite = new THREE.MeshBasicMaterial( {
        //                           color: 0xf41322,
        //                           transparent: true,
        //                           opacity: 1,
        //                           side: THREE.DoubleSide
        //                         } );
        //     const message = 'Merry Xmas !!',
        //           shapes = font.generateShapes( message, 50 ),
        //           text_geometry = new THREE.ShapeGeometry( shapes ),
        //           size = 1000;

        //     text_geometry.computeBoundingBox();

        //     const xmid = - 0.5 * ( text_geometry.boundingBox.max.x - text_geometry.boundingBox.min.x );

        //     text_geometry.translate( xmid, -200, 700, );

        //     const text = new THREE.Mesh( text_geometry, matLite );
        //         text.position.z = 20;
        //         scene.add( text );
        //         const holeShapes = [];
        //         for ( let i = 0; i < shapes.length; i ++ ) {
        //           let shape = shapes[ i ];
        //           if ( shape.holes && shape.holes.length > 0 ) {
        //             for ( let j = 0; j < shape.holes.length; j ++ ) {
        //               let hole = shape.holes[ j ];
        //               holeShapes.push( hole );
        //             }
        //           }
        //         }
        //         shapes.push.apply( shapes, holeShapes );
        //         const lineText = new THREE.Object3D();
        //         for ( let i = 0; i < shapes.length; i ++ ) {
        //           let shape = shapes[ i ],
        //               points = shape.getPoints(),
        //               text_geometry = new THREE.BufferGeometry().setFromPoints( points );
        //           text_geometry.translate( xmid + 10, -210, 700, );
        //           let lineMesh = new THREE.Line( text_geometry, matDark );
        //           lineText.add( lineMesh );
        //         }
        //         scene.add( lineText );
        //     }
        //  );
      }
      moveBody() {
      } 
    }


    init();
    animate();

    </script>
  </body>
</html>