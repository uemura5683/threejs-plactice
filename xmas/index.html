
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <script src="https://unpkg.com/three@0.131.3/build/three.min.js"></script>
    <style type="text/css">
      body {
        margin: 0;
        background-image:
          linear-gradient(
            0deg,
            #272d51 0%, #0c0e1b 40%, #000000 70%
          );
      }
    </style>
  </head>
  <body>
    <div id="myCanvas"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js",
          "three/addons/": "https://threejs.org/examples/jsm/"
        }
      }
    </script>    
    <script type="module">

    import { Lensflare, LensflareElement } from 'https://threejs.org/examples/jsm/objects/Lensflare.js';
    import { EffectComposer } from 'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
    import { AfterimagePass } from 'https://threejs.org/examples/jsm/postprocessing/AfterimagePass.js';

    /**
    * default
    **/
    let scene = null, camera = null, renderer = null, controls = null, xmastree  = null, snow = null, snow2 = null, spark = null, font = null, width = 0, height = 0;

    /**
    * init
    **/
    function init() {
      width = window.innerWidth,
      height = window.innerHeight;
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, width / height);
      camera.position.set(0, 160, 1700);
      renderer = new THREE.WebGLRenderer({
        alpha: true
      });
      renderer.setPixelRatio(
        window.devicePixelRatio
      );
      renderer.setSize(width, height);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      let composer = new EffectComposer(renderer);
      let renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      let afterimagePass = new AfterimagePass();
      composer.addPass( afterimagePass );

      afterimagePass.uniforms[ "damp" ].value = .6;

      
      addLights();
      drawXmasTree();
      drawSnow();
      drawSnow2();
      drawspark();
      drawfont();

      document.getElementById('myCanvas').appendChild(renderer.domElement);
      window.addEventListener('resize',onResize,false);
    }

    /**
    * lights
    **/
    function addLights() {
      decorationlignt(1,1,1);
      decorationlignt(-1,-1,-1);
    }

    function decorationlignt(px,py,pz) {
      const directLight = new THREE.DirectionalLight(0xffffff);
      directLight.castShadow = true;
      directLight.position.set(px, py, pz);
      scene.add(directLight);
    }

    /**
    * draw
    **/
    function drawXmasTree() {
      xmastree = new XmasTree();
      scene.add(xmastree.group);
    }

    function drawSnow() {
      snow = new Snow();
      scene.add(snow.group);
    }

    function drawSnow2() {
      snow2 = new Snow2();
      scene.add(snow2.group);
    }

    function drawspark() {
      spark = new Spark();
      scene.add(spark.group);
    }

    function drawfont() {
      font = new Font();
      scene.add(font.group);
    }

    /**
    * resize
    **/
    function onResize() {
      width = window.innerWidth;
      height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    /**
    * degree
    **/
    function degree(degrees) {
      return degrees * (Math.PI / 180);
    }

    /**
    * animate
    **/
    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    /**
    * render
    **/
    function render() {
      xmastree.moveBody();
      snow.moveBody();
      snow2.moveBody();
      spark.moveBody();
      font.moveBody();
      renderer.render(scene, camera);
    }

    /**
    * XmasTree
    **/
    class XmasTree {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, -100, 0);
        this.group.rotation.set(degree(0), degree(45), degree(0));
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        function floor(px,py,pz,rx,ry,rz,width,height,thickness,radius,color,group) {
          const floor = new THREE.CylinderGeometry(width, height, thickness, radius);
          const floor_material = new THREE.MeshPhongMaterial({color: color});
          const floor_mesh = new THREE.Mesh(floor, floor_material);
          floor_mesh.position.set(px, py, pz);
          floor_mesh.rotation.set(degree(rx), degree(ry), degree(rz));
          group.add(floor_mesh);
        }
        floor(0,-220,0,0,0,0,200,150,200,4,0xf41322,this.group);
        floor(0,-169,0,0,0,0,180,10,100,4,0x47232a,this.group);
        floor(0,100,0,0,0,0,30,30,800,100,0x50232C,this.group);
        floor(0,100,0,0,0,0,100,300,200,100,0x238B4A,this.group);
        floor(0,250,0,0,0,0,75,250,200,100,0x238B4A,this.group);
        floor(0,400,0,0,0,0,50,200,200,100,0x238B4A,this.group);
        floor(0,550,0,0,0,0,10,150,200,100,0x238B4A,this.group);
      }
      moveBody() {
        this.group.rotation.y += 0.01;
      }  
    }

    class Snow {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, -window.innerHeight, 0);
        this.group.rotation.set(degree(0), degree(0), degree(0));
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        for (let i = 0; i < 750; i++) {
          let star = ['snowflake1.png', 'snowflake2.png'];
          let starNo = Math.floor( Math.random() * star.length);
          let colors = [[ 1.0, 0.2, 0.8 ], [ 0.95, 0.1, 0.8 ], [ 0.90, 0.05, 0.8 ],[ 0.85, 0, 0.8 ], [ 0.80, 0, 0.8 ]];
          let colorsno = Math.floor( Math.random() * colors.length);
          let size = [20, 15, 10, 8, 5]
          let sizeNo = Math.floor( Math.random() * size.length);

          const snow_material = new THREE.SpriteMaterial({
            map: new THREE.TextureLoader().load(star[starNo]),
          });
          snow_material.fog = true;

          snow_material.color.setHSL( colors[colorsno][0], colors[colorsno][1], colors[colorsno][2] );

          const snow_sprite = new THREE.Sprite(snow_material);
          snow_sprite.position.x = (window.innerWidth * 2) * (Math.random() - 0.5);
          snow_sprite.position.y = (window.innerHeight * 2) * Math.random() - 40;
          snow_sprite.position.z = 2000 * (Math.random() - 0.5);

          snow_sprite.scale.set(size[sizeNo], size[sizeNo], size[sizeNo]);
          this.group.add(snow_sprite);
        }
      }
      moveBody() {
        this.group.rotation.y += 0.005;
      }  
    }

    class Snow2 {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, -window.innerHeight, 0);
        this.group.rotation.set(degree(0), degree(0), degree(0));
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        for (let i = 0; i < 750; i++) {
          let star = ['snowflake3.png'];
          let starNo = Math.floor( Math.random() * star.length);
          let colors = [[ 1.0, 0.2, 0.8 ], [ 0.95, 0.1, 0.8 ], [ 0.90, 0.05, 0.8 ],[ 0.85, 0, 0.8 ], [ 0.80, 0, 0.8 ]];
          let colorsno = Math.floor( Math.random() * colors.length);
          let size = [20, 15, 10, 8, 5]
          let sizeNo = Math.floor( Math.random() * size.length);

          const snow_material = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load(star[starNo]),});
          snow_material.fog = true;
          snow_material.color.setHSL( colors[colorsno][0], colors[colorsno][1], colors[colorsno][2] );

          const snow_sprite = new THREE.Sprite(snow_material);
          snow_sprite.position.x = (window.innerWidth * 2) * (Math.random() - 0.5);
          snow_sprite.position.y = (window.innerHeight * 2) * Math.random() - 40;
          snow_sprite.position.z = 2000 * (Math.random() - 0.5);

          snow_sprite.scale.set(size[sizeNo], size[sizeNo], size[sizeNo]);
          this.group.add(snow_sprite);
        }
      }
      moveBody() {
        this.group.rotation.y -= 0.005;
      }  
    }

    class Spark {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, 0, 0);
        this.group.rotation.set(0, 0, 0);
        this.wingangle = 0;
        this.bodyangle = 0;
        this.drawBody();
      }
      drawBody() {
        const body_geometry = new THREE.SphereGeometry( 30, 30, 30 );
        const body_material = new THREE.MeshPhongMaterial({transparent: true, opacity: .4,color: 0xffff91}); 
        const body          = new THREE.Mesh(body_geometry, body_material);
        body.position.set(0, 570, 0);
        this.group.add(body);
        const textureLoader = new THREE.TextureLoader();
        const textureFlare0 = textureLoader.load( 'lensflare.png' );
        addLight( 0.8, 0.9, 1, 0, 0, 0, this.group );
        function addLight( h, s, l, x, y, z, group ) {
          const light = new THREE.PointLight( 0xffffff, 1.5, 1000 );
          light.color.setHSL( h, s, l );
          light.position.set( x, y, z );
          group.add( light );
          const lensflare = new Lensflare();
          lensflare.addElement( new LensflareElement( textureFlare0, 200, 1, light.color ) );
          lensflare.position.set(0, -205, 205);
          group.add( lensflare );
        }
      }
      moveBody() {
      }  
    }

    /**
    * Font
    **/
    class Font {
      constructor() {
        this.group = new THREE.Group();
        this.group.position.set(0, 0, 0);
        this.wingangle = 0;
        this.fonts();
      }
      fonts() {
        const loader = new THREE.FontLoader();
        loader.load( 'https://threejs.org/examples/fonts/gentilis_bold.typeface.json', function ( font ) {
            const matDark = new THREE.LineBasicMaterial( {
                                  color: 0x50232C,
                                  opacity: 1,
                                  side: THREE.DoubleSide
                                } );
            const matLite = new THREE.MeshBasicMaterial( {
                                  color: 0xf41322,
                                  transparent: true,
                                  opacity: 1,
                                  side: THREE.DoubleSide
                                } );
            const message = 'Merry Xmas !!',
                  shapes = font.generateShapes( message, 50 ),
                  text_geometry = new THREE.ShapeGeometry( shapes ),
                  size = 1000;

            text_geometry.computeBoundingBox();

            const xmid = - 0.5 * ( text_geometry.boundingBox.max.x - text_geometry.boundingBox.min.x );

            text_geometry.translate( xmid, -200, 700, );

            const text = new THREE.Mesh( text_geometry, matLite );
                text.position.z = 20;
                scene.add( text );
                const holeShapes = [];
                for ( let i = 0; i < shapes.length; i ++ ) {
                  let shape = shapes[ i ];
                  if ( shape.holes && shape.holes.length > 0 ) {
                    for ( let j = 0; j < shape.holes.length; j ++ ) {
                      let hole = shape.holes[ j ];
                      holeShapes.push( hole );
                    }
                  }
                }
                shapes.push.apply( shapes, holeShapes );
                const lineText = new THREE.Object3D();
                for ( let i = 0; i < shapes.length; i ++ ) {
                  let shape = shapes[ i ],
                      points = shape.getPoints(),
                      text_geometry = new THREE.BufferGeometry().setFromPoints( points );
                  text_geometry.translate( xmid + 10, -210, 700, );
                  let lineMesh = new THREE.Line( text_geometry, matDark );
                  lineText.add( lineMesh );
                }
                scene.add( lineText );
            }
         );
      }
      moveBody() {
      } 
    }


    init();
    animate();

    </script>

    <!-- https://threejs.org/examples/#webgl_custom_attributes_lines // neon-->
    <!-- https://codepen.io/pehaa/pen/KKXMKMN?editors=0010 -->
  </body>
</html>